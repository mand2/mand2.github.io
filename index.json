[
{
	"uri": "/about/",
	"title": "About",
	"tags": [],
	"description": "",
	"content": "Chapter 0 About Backend 서버 개발자 고라니입니다.\n 1년차 신입 개발자 JAVA 70% Javascript 20% Python 10% 여러가지 기술에 관심이 많습니다.  "
},
{
	"uri": "/spring/",
	"title": "Spring",
	"tags": [],
	"description": "",
	"content": "Chapter 1 Spring "
},
{
	"uri": "/spring/user_register/1/",
	"title": "single-page 회원관리 폼 만들기",
	"tags": [],
	"description": "",
	"content": "  single page : CRUD(가입+수정+삭제+리스트 보여주기)를 Single page 처리 REST API 이용   개발순서 (MVC 2 패턴으로 함)\n DAO설정\nController\nService\nView\n 참고사항\n REST API 연습용입니다.\n기존에 사용하던 코드를 재활용하였으므로, 변수명의 차이가 있을 수 있습니다. 회원정보 수정에서의 parametertype 문제\nMap으로 설정해야 하나,\n빠르게 제작하기 위하여 model(DTO)인 EditMember를 parameter로 설정함. 회원가입시 not null 조건인 ID, PW, NAME만 기입하도록 하였습니다.  결과화면\n회원가입화면\n회원수정화면\n DAO 설정 //인터페이스 작성 public interface MemberDao { public Member selectById(String id) ; //회원한명의 정보가져오기(login + update ) \tpublic int deleteMember(int idx) ; //삭제 \t/* Rest Api를 위한 메서드 */ public List\u0026lt;Member\u0026gt; selectAllList(); public int insertMem(Member member); public int updateMem(Member member); //업데이트 수정 } \u0026lt;!-- mapper.xml 작성 --\u0026gt; \u0026lt;mapper namespace=\u0026#34;com.ny.mm.dao.MemberDao\u0026#34;\u0026gt; \u0026lt;!-- SQL의 컬럼명과 객체의 변수명(field)이 다르므로 resultMap을 통해 호환가능하도록 만듬 --\u0026gt; \u0026lt;resultMap type=\u0026#34;com.ny.mm.model.member.Member\u0026#34; id=\u0026#34;MemberVO\u0026#34;\u0026gt; \u0026lt;result property=\u0026#34;idx\u0026#34; column=\u0026#34;idx_m\u0026#34;/\u0026gt; \u0026lt;result property=\u0026#34;id\u0026#34; column=\u0026#34;id\u0026#34;/\u0026gt; \u0026lt;result property=\u0026#34;pw\u0026#34; column=\u0026#34;pw\u0026#34;/\u0026gt; \u0026lt;result property=\u0026#34;name\u0026#34; column=\u0026#34;name\u0026#34;/\u0026gt; \u0026lt;result property=\u0026#34;photo\u0026#34; column=\u0026#34;photo\u0026#34;/\u0026gt; \u0026lt;result property=\u0026#34;regDate\u0026#34; column=\u0026#34;regdate\u0026#34;/\u0026gt; \u0026lt;result property=\u0026#34;phone\u0026#34; column=\u0026#34;phone\u0026#34;/\u0026gt; \u0026lt;/resultMap\u0026gt; \u0026lt;!-- 회원한명의정보가져오기 --\u0026gt; \u0026lt;select id=\u0026#34;selectById\u0026#34; resultMap=\u0026#34;MemberVO\u0026#34; \u0026gt; select * from moonchild.member where id = #{id} \u0026lt;/select\u0026gt; \u0026lt;!-- 회원삭제 --\u0026gt; \u0026lt;delete id=\u0026#34;deleteMember\u0026#34;\u0026gt; delete from moonchild.member where idx_m = #{idx} \u0026lt;/delete\u0026gt; \u0026lt;!-- 회원리스트가져오기 --\u0026gt; \u0026lt;select id=\u0026#34;selectAllList\u0026#34; resultMap=\u0026#34;MemberVO\u0026#34;\u0026gt; select * from moonchild.member order by regdate desc \u0026lt;/select\u0026gt; \u0026lt;!-- 회원가입 --\u0026gt; \u0026lt;insert id=\u0026#34;insertMem\u0026#34; parameterType=\u0026#34;com.ny.mm.model.member.Member\u0026#34;\u0026gt; insert into moonchild.member (ID, PW, NAME) values (#{id}, #{pw}, #{name}) \u0026lt;/insert\u0026gt; \u0026lt;!-- 회원정보수정 --\u0026gt; \u0026lt;update id=\u0026#34;updateMem\u0026#34; parameterType=\u0026#34;com.ny.mm.model.member.EditMember\u0026#34;\u0026gt; update moonchild.member set name = #{name}, pw = #{pw} where idx_m = #{idx} \u0026lt;/update\u0026gt; \u0026lt;/mapper\u0026gt; Controller 설정  pw는 JsonIgnore로 설정되어 있음. /rest-api/members 공통 URI 설정 CRUD 설명  /rest-api/members method: GET 리스트 보여주기 /rest-api/members method: POST 회원가입 /rest-api/members/{id} method: GET 해당 아이디의 회원정보 보여주기(수정을 위함) /rest-api/members method: PUT 회원정보 수정 /rest-api/members/{idx} method: DELETE 회원 삭제(탈퇴)    회원수정(service, controller, DTO 등) 설명 회원수정이 가장 까다로웠으므로, REST API Controller 중 회원수정과 관련된 것(service와 controller, model 등)만 올립니다.\nservice @Autowired private SqlSessionTemplate template; private MemberDao dao; //수정할 멤버 가져오기 \tpublic Member select(String id) { dao = template.getMapper(MemberDao.class); Member member = dao.selectById(id); return member; } //해당멤버의 정보 변경 \tpublic int editRest(EditMember edit) { dao = template.getMapper(MemberDao.class); int result = 0; Member member = edit.toMemberRest(); result = dao.updateMem(member); return result; } controller @Controller @RequestMapping(\u0026#34;/rest-api/members\u0026#34;) public class RestApiController { @Autowired private memEditService editService; //수정:회원정보가져오기 \t@CrossOrigin @ResponseBody @RequestMapping(value = \u0026#34;/{id}\u0026#34;, method = RequestMethod.GET) public Member geteditMember(@PathVariable(\u0026#34;id\u0026#34;) String id) { return editService.select(id); } //회원수정 \t@CrossOrigin @ResponseBody @RequestMapping(method = RequestMethod.PUT) public int editMember(@RequestBody EditMember edit) { return editService.editRest(edit); } }    @Contoroller RestApiController 를 controller로 인식하도록 어노테이션 설정.     @CrossOrigin client와 server를 분리할 때 발생할 수 있는 크로스도메인 이슈를 해결하기 위한 설정. 해당 이슈는 서버측에서 해결하는 게 보편적이라 함. client가 요청하는 위치가 달라도 해당 메서드를 사용할 수 있도록 한다.    RequestParam 과 PathVariable\n RequestParam 은 naver.com/search?page=12와 같이 URL 자체에 전달된 parameter를 호출\nPathVariable 은 naver.com/search/index/1REST API에서 값을 호출할 때 사용\n RequestMapping의 value = \u0026ldquo;{ 템플릿변수 }\u0026ldquo;의 템플릿 변수와 @PathVariable 어노테이션에서 불러오는 템플릿 변수는 동일한 이름(변수명)을 갖는다. 해당 템플릿변수를 불러와 변수로 사용가능!     view //수정버튼 클릭시 실행(수정할 멤버의 정보 가져오기) function edit(id) { if(confirm(\u0026#39;정말 수정할거야?????리얼리????\u0026#39;)){ $.ajax({ url:\u0026#39;http://localhost:8080/mc/rest-api/members/\u0026#39;+id, type: \u0026#39;GET\u0026#39;, error: function() { alert(\u0026#39;error.....\u0026#39;); list(); }, success: function(data) { //alert(data.idx);  $(\u0026#39;#join\u0026#39;).css(\u0026#39;display\u0026#39;,\u0026#39;none\u0026#39;); //가입폼 안보이게 하고  $(\u0026#39;#edit\u0026#39;).css(\u0026#39;display\u0026#39;,\u0026#39;block\u0026#39;); //수정폼 보이게  var output = \u0026#39;\u0026#39;; output += \u0026#39;아이디는안바꿔줘\u0026#39; output += \u0026#39;\u0026lt;input type=\u0026#34;text\u0026#34; value=\u0026#34;\u0026#39;+data.id +\u0026#39;\u0026#34; disabled\u0026gt;\u0026lt;br\u0026gt;\\n\u0026#39;; output += \u0026#39;패스워드는?????? \u0026#39;; output += \u0026#39;\u0026lt;input type=\u0026#34;password\u0026#34; id=\u0026#34;pw2\u0026#34; name=\u0026#34;pw\u0026#34;\u0026gt; \u0026lt;br\u0026gt;\\n\u0026#39;; output += \u0026#39;이름 좀 알려줄래?\u0026#39;; output += \u0026#39;\u0026lt;input type=\u0026#34;text\u0026#34; id=\u0026#34;name2\u0026#34; name=\u0026#34;name\u0026#34;\u0026gt; \u0026lt;br\u0026gt;\\n\u0026#39;; output += \u0026#39;\u0026lt;span class=\u0026#34;submit\u0026#34; onclick=\u0026#34;getEdit(\u0026#39;+data.idx+\u0026#39;)\u0026#34;\u0026gt;\u0026#39;; output += \u0026#39;수정할래요오오오옹!\u0026lt;/span\u0026gt;\u0026#39;; $(\u0026#39;#editForm\u0026#39;).html(output); } }); } } //수정할래요오오오옹! 이라는 버튼을 클릭 할 때 (== 수정 update 전송 버튼) function getEdit(idx) { $.ajax({ url:\u0026#39;http://localhost:8080/mc/rest-api/members\u0026#39;, type: \u0026#39;PUT\u0026#39;, data: JSON.stringify({ idx: idx, pw : $(\u0026#39;#pw2\u0026#39;).val(), name : $(\u0026#39;#name2\u0026#39;).val() }), contentType: \u0026#39;application/json;charset=utf-8\u0026#39;, dataType: \u0026#39;json\u0026#39;, success: function(data) { if(data \u0026gt; 0 ){ alert(\u0026#39;수정되었습니다\u0026#39;); } else { alert(\u0026#39;실-패\u0026#39;); } }, error: function(){ alert(\u0026#39;error ㅠㅠㅠㅠ\u0026#39;); }, complete: function() { list(); $(\u0026#39;#edit\u0026#39;).css(\u0026#39;display\u0026#39;,\u0026#39;none\u0026#39;); $(\u0026#39;#join\u0026#39;).css(\u0026#39;display\u0026#39;,\u0026#39;block\u0026#39;); } }); } TIL   complete  를 쓰면 성공/에러에 상관없이 실행함.\n가독성이 좋아짐!\n순서는 success - complete 혹은 error - complete 순. edit 에서는 controller에서 Member 타입으로 받아오기 때문에 data.id 와 같이 get메서드를 호출 할 수 있다. getEdit 은 result값을 int 타입으로 받도록 만들어 success 에서 바로 체크하도록 함.   추가: EditMember public class EditMember { /** * 참고로 REST-API에서만 사용하는 변수/메서드만 편집하여 올림 * getter setter 설정하였음. */ private int idx; private String id; private String pw; private String name; public Member toMemberRest() { Member member = new Member(); member.setIdx(idx); member.setPw(pw); member.setName(name); return member; } } "
},
{
	"uri": "/about/portfolio/",
	"title": "Portfolio",
	"tags": [],
	"description": "",
	"content": "portfolio created in Oct, 2019.\n"
},
{
	"uri": "/spring/user_register/2/",
	"title": "Spring handler 인터셉터",
	"tags": [],
	"description": "",
	"content": "필터와 인터셉터의 실행시기 차이? 실행시점은 차이가 있음\n인터셉터 중 핸들러인터셉터는 필터의 일종이긴 하나, 요청컨트롤러가 있고 확인이 된 후에 실행(컨트롤러 요청 전후) 됨\n핸들러 인터셉터 핸들러 인터셉터는 DispatcherServlet 이 컨트롤러를 호출하기 전과 후에 요청과 응답을 참조하거나 가공할 수 있는 일종의 필터\n필터와 인터셉터의 자세한 차이를 알고싶다면 여기로\nHandlerInterceptor 어떻게 쓸까? HandlerInterceptorAdaptor 클래스를 상속받은 뒤, 자신이 원하는 메서드만 오버라이딩하면 된다.\n~'Adaptor'가 붙어있는 클래스 인터페이스 구현체이나, 안에 내용이 없음. 내가 구현하고자 하는 메서드만 재구성하면 됨. 즉 구현하지 않아도 될 메서드들은 구현하지 않음! 번거로움이 줄어든다.   HandlerMapping에 인터셉터 설정 (servlet-context.xml 에 등록)\n  Interceptor 실행순서?\npreHandle: HandlerMapping에 등록된 순서대로 실행\npostHandle: 등록 순서와 역순으로 실행\n  view 렌더링 한 후: \u0026lsquo;Interceptor 처리 완료 후\u0026rsquo; 혹은 \u0026lsquo;뷰 생성 후\u0026rsquo;라 할 수 있으며, 등록된 순서의 반대로 afterCompletion() 실행\n  1. servlet-context.xml 에 등록 \u0026lt;!-- interceptor 등록 --\u0026gt; \u0026lt;interceptors\u0026gt; \u0026lt;interceptor\u0026gt; \u0026lt;mapping path=\u0026#34;/member/mypage/**\u0026#34;/\u0026gt; \u0026lt;exclude-mapping path=\u0026#34;/member/mypage/help\u0026#34;/\u0026gt; \u0026lt;beans:bean class=\u0026#34;com.ny.mm.interceptor.AuthCheckInterceptor\u0026#34; /\u0026gt; \u0026lt;/interceptor\u0026gt; \u0026lt;/interceptors\u0026gt; 2. interceptor class 등록  목표:\n세션에 loginInfo 속성이 존재하면 return true 해주기\n public class AuthCheckInterceptor extends HandlerInterceptorAdapter { @Override public boolean preHandle(HttpServletRequest request, HttpServletResponse response, Object handler) throws Exception { //\t1. 현재 요청에서 세션객체 받기  HttpSession session = request.getSession(false); //\t2. loginInfo가 저장되어있는지,,  if(session != null \u0026amp;\u0026amp; session.getAttribute(\u0026#34;loginInfo\u0026#34;) != null) { return true; } //context 경로 지정해줘야한다.  response.sendRedirect(request.getContextPath() + \u0026#34;/login/form\u0026#34;); return false; } } 3. VIEW 등록 (jsp) \u0026lt;%@ page language=\u0026quot;java\u0026quot; contentType=\u0026quot;text/html; charset=UTF-8\u0026quot; pageEncoding=\u0026quot;UTF-8\u0026quot;%\u0026gt; \u0026lt;!DOCTYPE html\u0026gt; \u0026lt;html\u0026gt; \u0026lt;head\u0026gt; \u0026lt;meta charset=\u0026quot;UTF-8\u0026quot;\u0026gt; \u0026lt;title\u0026gt;Insert title here\u0026lt;/title\u0026gt; \u0026lt;/head\u0026gt; \u0026lt;body\u0026gt; \u0026lt;h1\u0026gt;삐용삐용!!!!!!!!!!!! null pointer exception 발생!!!!!!!!!!!!\u0026lt;/h1\u0026gt; \u0026lt;/body\u0026gt; \u0026lt;/html\u0026gt; 4. 결과페이지 확인 ![결과페이지]({{ /images/Spring/2_1.jpg }})\n"
},
{
	"uri": "/spring/user_register/3/",
	"title": "Spring 웹상에서 메일 보내보기",
	"tags": [],
	"description": "",
	"content": "웹상에서 메일 보내보기 목차  설정\n-1 pom.xml\n-2 servlet-context\n-3 Controller\n-4 왜 MailSender 사용가능할까?\n-5 보낸사람이 다를 때? Java Mail API로 메일 작성하기\n-1 Java Mail API 란?\n-2 HTML 형식으로 보내기\n-3 파일 첨부하기  설정부터 해보자! 1. pom.xml에서 메일 설정 \u0026lt;!-- 메일 설정 시작 --\u0026gt; \u0026lt;!-- javax.mail/mail --\u0026gt; \u0026lt;dependency\u0026gt; \u0026lt;groupId\u0026gt;javax.mail\u0026lt;/groupId\u0026gt; \u0026lt;artifactId\u0026gt;mail\u0026lt;/artifactId\u0026gt; \u0026lt;version\u0026gt;1.4.7\u0026lt;/version\u0026gt; \u0026lt;/dependency\u0026gt; \u0026lt;dependency\u0026gt; \u0026lt;groupId\u0026gt;org.springframework\u0026lt;/groupId\u0026gt; \u0026lt;artifactId\u0026gt;spring-context-support\u0026lt;/artifactId\u0026gt; \u0026lt;version\u0026gt;${org.springframework-version}\u0026lt;/version\u0026gt; \u0026lt;/dependency\u0026gt; 2. servlet-context 설정 \u0026lt;beans:bean id=\u0026#34;mailSender\u0026#34; class=\u0026#34;org.springframework.mail.javamail.JavaMailSenderImpl\u0026#34;\u0026gt; \u0026lt;beans:property name=\u0026#34;host\u0026#34; value=\u0026#34;smtp.gmail.com\u0026#34; /\u0026gt; \u0026lt;beans:property name=\u0026#34;port\u0026#34; value=\u0026#34;587\u0026#34; /\u0026gt;\u0026lt;!-- 465 or 25 --\u0026gt; \u0026lt;beans:property name=\u0026#34;username\u0026#34; value=\u0026#34;본인 이메일 계정\u0026#34; /\u0026gt; \u0026lt;beans:property name=\u0026#34;password\u0026#34; value=\u0026#34;해당 계정의 비밀번호\u0026#34; /\u0026gt; \u0026lt;beans:property name=\u0026#34;defaultEncoding\u0026#34; value=\u0026#34;utf-8\u0026#34; /\u0026gt; \u0026lt;beans:property name=\u0026#34;javaMailProperties\u0026#34;\u0026gt; \u0026lt;beans:props\u0026gt; \u0026lt;beans:prop key=\u0026#34;mail.transport.protocol\u0026#34;\u0026gt;smtp\u0026lt;/beans:prop\u0026gt; \u0026lt;beans:prop key=\u0026#34;mail.smtp.auth\u0026#34;\u0026gt;true\u0026lt;/beans:prop\u0026gt; \u0026lt;beans:prop key=\u0026#34;mail.smtp.starttls.enable\u0026#34;\u0026gt;true\u0026lt;/beans:prop\u0026gt; \u0026lt;beans:prop key=\u0026#34;mail.debug\u0026#34;\u0026gt;true\u0026lt;/beans:prop\u0026gt; \u0026lt;/beans:props\u0026gt; \u0026lt;/beans:property\u0026gt; \u0026lt;/beans:bean\u0026gt; 3. Controller 작성 @Controller public class MailSendController { @Autowired MailSender sender; @ResponseBody @RequestMapping(\u0026#34;/mail/send\u0026#34;) public String sendMail() { //메일내용설정해주기 \tSimpleMailMessage message = new SimpleMailMessage(); message.setTo(\u0026#34;보내는사람 이메일~~\u0026#34;); message.setSubject(\u0026#34;hiiiiiiiiiiiii\u0026#34;); message.setText(\u0026#34;my first email to send a letter\u0026#34;); message.setFrom(\u0026#34;받는사람 이메일!!\u0026#34;); sender.send(message); return \u0026#34;send OK\u0026#34;; } } 왜 MailSender를 사용할 수 있을까? bean으로 설정된 mailSender는 JavaMailSenderImpl 클래스임.\n이 클래스는 JavaMailSender 인터페이스의 구현체. JavaMailSender를 살펴본다면,\npublic interface JavaMailSender extends MailSender {} 즉, MailSender를 상속받기 때문에 다형성이 가능하므로 컨트롤러에서 MailSender 클래스를 주입받을 수 있게 된다.\n보낸사람을 설정해줬는데도 bean에서 설정한 메일주소로 보내지는 이유 google의 보안정책이 바뀌어서 설정된 계정으로만 보내짐.\ngoogle 계정을 쉽게 만들 수 있기도 하고, 이를 악용하여 악성코드를 보낼 수도 있기 때문인게 아닌가 싶다.\n그러면 이제 Java Mail API로 메일을 작성해보자! Java Mail API 가 뭐야?  파일 첨부 또는 HTML로 구성되어 있는 경우 MimeMessage 이용  JavaMailSender 인터페이스는 MimeMessage 객체를 생성해주는 createMimeMessage() 메서드를 제공 이 메서드가 리턴한 MimeMessage 객체를 이용해서 메시지를 구성한 뒤 메일 발송  1. HTML 형식으로 보내보기 @Autowired JavaMailSender jmsender; @ResponseBody @RequestMapping(\u0026#34;/mail/send/javamail\u0026#34;) public String sendJavaMailSender() { MimeMessage message = jmsender.createMimeMessage(); try { //메일제목설정  message.setSubject(\u0026#34;[안내] 처음보내는 JAVAMAIL SENDER\u0026#34;, \u0026#34;utf-8\u0026#34;); //html메일내용  String htmlStr = \u0026#34;\u0026lt;h1 style=\\\u0026#34;color: lightblue;\\\u0026#34;\u0026gt;hi everyone~~\u0026lt;/h1\u0026gt;\u0026#34; + \u0026#34;\u0026lt;a href=\\\u0026#34;http://www.naver.com\\\u0026#34;\u0026gt;naver\u0026lt;/a\u0026gt;\u0026#34;; //내용설정  message.setText(htmlStr, \u0026#34;utf-8\u0026#34;, \u0026#34;html\u0026#34;); //TO 설정  message.addRecipient(RecipientType.TO, new InternetAddress(\u0026#34;받는사람메일계정\u0026#34;, \u0026#34;mand2 님\u0026#34;, \u0026#34;utf-8\u0026#34;)); jmsender.send(message); } catch (MessagingException e) { e.printStackTrace(); } catch (UnsupportedEncodingException e) { e.printStackTrace(); } return \u0026#34;send OK\u0026#34;; } setText 메서드: subtype을 설정해주지 않으면 그냥 다 전해짐,, 태그를 텍스트로 인식!\nTo설정에서 new InternetAddress를 사용하는 이유?\n받는사람의 메일계정이 아닌 사용자 이름으로 보내줄 수 있음\n2. 파일 첨부해서 보내보기 스프링이 제공하는 MimeMessageHelper 클래스를 사용\n@RequestMapping(\u0026#34;/mail/send/file\u0026#34;) @ResponseBody public String sendFileAttach() { MimeMessage message = jmsender.createMimeMessage(); try { MimeMessageHelper helper = new MimeMessageHelper(message, true, \u0026#34;utf-8\u0026#34;); //title  helper.setSubject(\u0026#34;[info] file attatched\u0026#34;); //content html  String htmlStr = \u0026#34;\u0026lt;h1\u0026gt;file has been attatched.\u0026#34; + \u0026#34;please download the file I send \u0026lt;/h1\u0026gt;\u0026#34;; //content setting  helper.setText(htmlStr, true); //to  helper.setTo(new InternetAddress(\u0026#34;받는사람 메일주소\u0026#34;, \u0026#34;만득이 님\u0026#34;, \u0026#34;utf-8\u0026#34;)); //create file instance + absolute root  DataSource dataSource = new FileDataSource(\u0026#34;절대경로루트\u0026#34;); helper.addAttachment(MimeUtility.encodeText(\u0026#34;파일이름\u0026#34;, \u0026#34;utf-8\u0026#34;, \u0026#34;B\u0026#34;), dataSource); jmsender.send(message); } catch (MessagingException e) { e.printStackTrace(); } catch (UnsupportedEncodingException e) { e.printStackTrace(); } return \u0026#34;send ok\u0026#34;; } #1 MimeMessage 객체로 메세지생성\n#2 MimeMessageHelper 객체 생성 ( 메세지객체, 파일유무, charset)\n#3 메일 제목 설정\n#4 내용 html 설정\n#5 받는사람 설정\n#6 보낼 파일 설정\n​\t파일 위치\n​\t파일이름 설정\n​\t- MimUtility 의 encodeText 메서드를 이용\n​\t- 파일이름(한글일 때) 설정\n#7 해당 메세지 객체를 send 해주기\n"
},
{
	"uri": "/spring/user_register/4/",
	"title": "회원가입 시 이메일 인증처리",
	"tags": [],
	"description": "",
	"content": "회원 가입 시 email을 받고 인증 코드를 생성, 해당 email 계정으로 인증 처리 메일을 보내보자! 관리자가 보낸 인증코드가 맞다면 인증 완료처리까지- 먼저 mySQL에서 컬럼 추가해준다. -- 인증코드와 verify 확인 코드 ALTER TABLE `project_01`.`memberinfo` ADD COLUMN `code` VARCHAR(25) NULL AFTER `REGDATE`, ADD COLUMN `verify` CHAR(1) NULL DEFAULT \u0026#39;N\u0026#39; AFTER `code`, ADD COLUMN `email` VARCHAR(45) NULL AFTER `verify`; DAO 변경 DAO 변경\n//verify public int updateVerify(String id, String code); public int updateEmail(Member member); Mapper. xml 변경\n\u0026lt;!-- result map 설정 추가 --\u0026gt; \u0026lt;resultMap type=\u0026#34;com.ny.mm.model.Member\u0026#34; id=\u0026#34;MemberVO\u0026#34;\u0026gt; \u0026lt;result property=\u0026#34;idx\u0026#34; column=\u0026#34;idx\u0026#34;/\u0026gt; \u0026lt;result property=\u0026#34;id\u0026#34; column=\u0026#34;id\u0026#34;/\u0026gt; \u0026lt;result property=\u0026#34;pw\u0026#34; column=\u0026#34;pw\u0026#34;/\u0026gt; \u0026lt;result property=\u0026#34;name\u0026#34; column=\u0026#34;name\u0026#34;/\u0026gt; \u0026lt;result property=\u0026#34;photo\u0026#34; column=\u0026#34;photo\u0026#34;/\u0026gt; \u0026lt;result property=\u0026#34;regDate\u0026#34; column=\u0026#34;regdate\u0026#34;/\u0026gt; \u0026lt;result property=\u0026#34;code\u0026#34; column=\u0026#34;code\u0026#34;/\u0026gt; \u0026lt;result property=\u0026#34;verify\u0026#34; column=\u0026#34;verify\u0026#34;/\u0026gt; \u0026lt;result property=\u0026#34;email\u0026#34; column=\u0026#34;email\u0026#34;/\u0026gt; \u0026lt;/resultMap\u0026gt; \u0026lt;!-- 회원가입시 code, email도 DB에 연결해주기 --\u0026gt; \u0026lt;insert id=\u0026#34;insertMember\u0026#34; parameterType=\u0026#34;com.ny.mm.model.Member\u0026#34;\u0026gt; insert into project_01.memberinfo (ID, PW, NAME, PHOTO, CODE, EMAIL) values (#{id}, #{pw}, #{name}, #{photo}, #{code}, #{email}) \u0026lt;/insert\u0026gt; \u0026lt;!-- 인증 확인 처리 --\u0026gt; \u0026lt;update id=\u0026#34;updateVerify\u0026#34;\u0026gt; update project_01.memberinfo set verify = \u0026#39;Y\u0026#39; where id = #{param1} and code = #{param2} \u0026lt;/update\u0026gt;\tmodel에 변수 추가  변경해야 할 java 파일 :\n-Member.java\n-JoinRestApiRequest.java //회원 가입 시 받는 객체\n-LoginInfo.java //로그인 할 때 생성하는 객체\n-VerifyMember.java : 새로 생성하는 파일\n Member.java @JsonIgnore private String code; private char verify; private String email; public Member(String id, String email) { this.id = id; this.email = email; randomCode(); } //영대소문자+숫자 난수 public void randomCode() { StringBuffer temp = new StringBuffer(); Random rnd = new Random(); String str = String.valueOf( (char) (rnd.nextInt(26) + 97) ); for(int i = 0; i \u0026lt; 10; i++) { //10자리 난수발생  int index = rnd.nextInt(3); //숫자 012 중에서 난수 발생시킴  switch (index) { case 0: //97~122 a-z의 아스키코드  temp.append((char)(rnd.nextInt(26) + 97)); break; case 1: temp.append((char)(rnd.nextInt(26) + 65)); break; case 2: temp.append(rnd.nextInt(10)); break; } } System.out.println(\u0026#34;난수코드생성: \u0026#34; + temp); setCode(temp.toString()); } 다른 파일들은 변수 추가하고 getter, setter 설정과 toString 오버라이딩 정도로 하면 됨.\nService 단: MailSenderService.java 파일 생성\nJoinService 파일 변경 MailSenderService.java 생성 @Service(\u0026#34;mailSenderService\u0026#34;) public class MailSenderService { @Autowired private JavaMailSender sender; public int send(Member member) { int result = 0; MimeMessage message = sender.createMimeMessage(); String name = member.getName() + \u0026#34; 님\u0026#34;; String email = member.getEmail(); String id = member.getId(); String code = member.getCode(); try { message.setSubject(\u0026#34;[info] Welcome TO Our WEBSITE\u0026#34;, \u0026#34;utf-8\u0026#34;); String htmlMsg = \u0026#34;\u0026lt;h1\u0026gt;회원가입을 축하합니다~\u0026lt;/h1\u0026gt;\u0026#34;; htmlMsg += \u0026#34;\u0026lt;h1\u0026gt;사랑합니다 \u0026#34;+name+\u0026#34;!\u0026lt;/h1\u0026gt;\u0026#34;; htmlMsg += \u0026#34;\u0026lt;a href = \\\u0026#34;http://localhost:8080/mm/join/verify?id=\u0026#34;+id+\u0026#34;\u0026amp;code=\u0026#34;+code+\u0026#34;\\\u0026#34;\u0026gt;인증하기 클릭\u0026lt;/a\u0026gt;\u0026#34;; message.setText(htmlMsg, \u0026#34;utf-8\u0026#34;, \u0026#34;html\u0026#34;); message.addRecipient(RecipientType.TO, new InternetAddress(email, name, \u0026#34;utf-8\u0026#34;)); sender.send(message); } catch (MessagingException e) { e.printStackTrace(); } catch (UnsupportedEncodingException e) { e.printStackTrace(); } return 1; } } id를 이메일 계정으로 받지 않고 이메일 계정을 따로 만들었으므로, 보낼 때 id, name, email 등등 여러가지를 parameter로 넘기는게 번거로워서 Member객체로 바로 넘겨버림. 인증을 할 때 \u0026lt;a\u0026gt;태그에 가입한 사람의 아이디와 코드를 보내준다.\nmail 보내는 설정을 자세하게 알고싶다면 여기로\n### JoinService 변경 @Autowired private MailSenderService mailService; //가입 서비스 rest + email 사용 public int joinMember( HttpServletRequest request, JoinRestApiRequest joinMember ) { /*생략*/ //파일 올렸을 때  if(joinMember.getPhoto() != null) { //file을 서버의 지정 경로에 저장.  newFileName = System.nanoTime() + \u0026#34;_\u0026#34; + joinMember.getId(); joinMember.getPhoto().transferTo(new File(dir, newFileName)); //데이터베이스 저장을 하기위한 파일이름 세팅  memberinfo.setPhoto(newFileName); } result = dao.insertMember(memberinfo); mailService.send(memberinfo); /*생략*/ return result; } join을 하면서 바로 같이 mailService의 send메서드를 통해 인증메일 보냄.\nController: 이메일 인증 처리해주기 @Controller public class VerifyController { @Autowired private VerifyService verifyService; @RequestMapping(\u0026#34;/join/verify\u0026#34;) public String verify(@RequestParam(\u0026#34;id\u0026#34;)String id, @RequestParam(\u0026#34;code\u0026#34;)String code) { return \u0026#34;join/verify_\u0026#34; + verifyService.verify(id, code); } } 인증처리가 제대로 되었다면 join/verify_Y로, 아니라면 join/verify_N 이라는 이름의 view로 들어가게 설정\n메일함을 열어본다면 이렇게 나온다\n결과화면: 인증완료 결과화면: 인증미완료 "
},
{
	"uri": "/spring/user_register/5/",
	"title": "메이븐 빌드 및 배포란?",
	"tags": [],
	"description": "",
	"content": "메이븐은 프로젝트 객체 모델(Project Object Model)이라는 개념을 바탕으로 프로젝트 의존성 관리, 라이브러리 관리, 프로젝트 생명 주기 관리 기능 등을 제공하는 프로젝트 관리 도구이다. 또한 플러그인을 기반으로 소스 코드로부터 배포 가능한 산출물을 만들어 내는 빌드 기능 뿐만 아니라 레포팅 및 documentation 작성 기능 등을 제공한다.\n메이븐 자세히 알아보러 가기\npom.xml 태그들 자세히 알아보기\npom.xml 태그 조금 더 간결하게, 정리 더 잘 된 것\nmaven (메이븐 구조, 차이점, 플러그인, 라이프사이클, 의존성, pom.xml)\n자바 웹 어플리케이션 배포  SVN 으로 형상관리 하는 경우도 있다 (회사에서,,) git으로 형상관리 하기  배포 순서 :\n 각자 소스 코딩 후 형상관리 툴에 push 배포용 서버 컴퓨터에서 pull 받음 war 파일로 package tomcat에 배포  "
},
{
	"uri": "/categories/",
	"title": "Categories",
	"tags": [],
	"description": "",
	"content": ""
},
{
	"uri": "/",
	"title": "GoRaNee&#39;s dev-log",
	"tags": [],
	"description": "",
	"content": ""
},
{
	"uri": "/categories/spring/",
	"title": "Spring",
	"tags": [],
	"description": "",
	"content": ""
},
{
	"uri": "/spring/user_register/",
	"title": "회원가입",
	"tags": [],
	"description": "",
	"content": ""
},
{
	"uri": "/tags/",
	"title": "Tags",
	"tags": [],
	"description": "",
	"content": ""
}]