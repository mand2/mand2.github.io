---
title: "[Spring-Boot] 스프링부트 어노테이션: @SpringBootApplication"
categories: Spring-Boot
date: 2019-10-21 09:24:00
---

<br><br>

# :scream: ​왜 Spring Boot 배포가 되지 않는걸까?

프로젝트 팀 작업을 하면서 spring boot 배포를 하는 친구들이 build 오류가 난다고 했다. 처음엔 git에서 파일을 pull 할 때 제대로 못한게 아닐까 싶었는데, 그런 오류는 아니었다. 

해당 배포하는 깃에 들어가 파일을 보니, 다음과 같은 구조로 되어있었다.

![배포실패path](https://mand2.github.io/assets/images/spring-4/boot_1021_path.JPG)



<br>

자세히보면 `src/main/java/com/ycar` 내부에 `~Application.java` 라는 파일이 두개가 있다. 즉, `@SpringBootApplication` 어노테이션이 붙은 클래스가 두개이며, 어플리케이션 주입 처리가 잘못되어있다는 것을 알 수 있다.

<br><br>

![배포실패pom](https://mand2.github.io/assets/images/spring-4/boot_1021_pom.JPG)

심지어 pom.xml 에서 @SpringBootApplication이 시작하는 루트도 잘못되어 있음을 알 수 있다

```java
<groupId>com.exmaple</groupId>
```

이 아니라, 
```java
<groupId>com.ycar.boot</groupId>
```

로 시작해야한다.



<br><br>

# :key: maven build 오류가 있다! 

현재 오류의 문제점은

1. package 루트가 중복으로 되어있다는 점
   `src/main/java/com/ycar` 내부에 **par과 passenger** 로 나뉘어야 한다. 

   현재는 passenger 패키지 부분이 중복으로 들어가 있는 것을 알 수 있다. 아마 버전 업데이트를 하면서 복사-붙여넣기를 하다 중복이 된 것이 아닐까 싶다.

2. pom.xml 에서 groupId와 artifactId, name을 변경해야 한다. 기존에 setting 했던 id와 name이 덮어씌워지면서 충돌이 나고 있다.

3. test 패키지에 있는 passenger 파일도 삭제해야 한다. @SpringBootApplication 을 하나로 명시하고자 하기때문에, test 패키지도 정리해야 한다.

-------------

build 실패를 위의 **문제점 1~3 과 같이** 어림짐작으로 해결했는데, 왜 이렇게 되는지 그 원인과 구조를 알고싶었다.

<br><br><br>



# @SpringBootApplication 이란?

잠시 돌아가서, 이 `@SpringBootApplication`이 뭐기에 빌드 오류를 뱉어내는지 보자



### 1. @SpringBootApplication의 의미는

  @Configuration + @EnableAutoConfiguration + @ComponentScan 을 합친 것이다.

  

### -1 **@Configuration** 이란?

- 현재 클래스가 **Spring의 설정 파일**임을 알려주는 어노테이션

- ==  Spring이 Java config로 간주한다!
- Configuration을 클래스에 적용하고 @Bean을 해당 클래스의 메소드에 적용하면   
  @Autowired로 빈을 부를 수 있다.

- 개발자가 생성한 class를 Bean으로 생성 할 때 **Single Tone**으로 한번만 생성하고   
    @Component는 Bean을 생성 할 때 java에서 new로 생성하듯이 생성한다.

<br>

### -2 **@EnableAutoConfiguration** 이란?

* Spring boot 클래스패스 세팅 및 다양한 Bean 추가 등을 시켜주는 어노테이션

* 어플리케이션에 추가된 설정들을 자동으로 추가해주는 어노테이션

<br>



### -3 **@ComponentScan** 이란?

* 다른 컴포넌트, 서비스, 설정 등을 찾을 수 있게 도와주는 어노테이션  
  즉 자바 클래스를 **스프링 빈이라고 표시**하고   
  스프링의 component-scanning 기술을 통해 ApplicationContext에 빈으로 등록하게 하는 역할

* == @Component를 검색하도록 도와준다

* @Configuration 클래스도 컴포넌트로서 검색 대상이 된다.

  > 스프링은 기본적으로 객체를 자동으로 생성하여 관리하기 때문에 @Component 어노테이션이 있는 클래스들을 스프링 컨테이너가 생성해준다. @ComponentScan는 특별히 basePackage를 지정하지 않아도 main class가 위치한 패키지를 Root package로 하여 그 이하의 모든 컴포넌트 클래스들을 검색하여 빈으로 등록한다.

* 메인 클래스인 **`YcarBootServerApplication` ** 를 보면, 이 클래스는 `com.ycar.boot` 패키지에 있다. 이 패키지가 컴포넌트 스캔의 **루트패키지**가 된다. 따라서 com.ycar.boot 패키지를 기준으로 그 하위에 있는(== 하위 패키지) 모든 컴포넌트들을 검색한다. 

* **(주의)** pom.xml에서 루트 패키지를 정확하게 매칭시켜야 한다. 
  
* Spring XML설정의 `<context:component-scan>`을 대신해 자바에 설정

* 컴포넌트에 대해서는 아래에 따로 기술!

<br><br>

### 2 @Component :  @Repository, @Service, @Controller

@Repository, @Service, @Controller는 @Component에 속한 어노테이션이다.

<br>

### 2 - 1 왜 @Component 대신 쓸까? 

> @Repository  
> @Service  
> @Contoller - @RestController

** 3가지 종류의 컴포넌트가 다른 이름을 가진 이유는 **레이어를 구분**하기 위함



### 2 - 2 @Repository 어노테이션

DAO에 특화된 어노테이션이다. @Component 어노테이션을 써도 상관없지만, DAO 클래스들에 @Repository 어노테이션을 사용함으로써 @Component 어노테션이 가진 특성과 함께, DAO의 메소드에서 발생할 수 있는 unchecked exception들을 스프링의 DataAccessException으로 처리할 수 있는 장점 또한 가질 수 있다.



### 2 - 3 @Service 어노테이션

서비스 레이어 클래스들에 사용되어지는 어노테이션이다. 역시나 @Component 어노테이션을 사용해도 상관없다. @Service 어노테이션을 사용함으로써 해당 클래스가 서비스 레이어 클래스라는 것을 명확하게 할 수 있다. 현재는 @Repository 어노테이션 처럼 추가적인 behavior는 없지만, 추후에 추가될 예정이다.



### 2 - 4 @Controller 어노테이션

MVC 패턴에서 Controller 클래스에 선언되어진다. 이 또한 @Component 로 대체할 수 있다. 하지만, @Controller 어노테이션을 사용함으로써 @RequestMapping 등의 추가적인 어노테이션을 사용할 수 있게 된다.



### 2 - 5 

** 실제 프로젝트에서 @Component가 필요한 비슷한 상황들을 직면하곤 한다. 하지만, 대부분의 상황에서 우리는 @Repository, @Service, @Controller 어노테이션을 사용하는게 좋다고 한다.

<br><br>

<br><br>

# Spring 빈 컨테이너 : 주기 관리

이렇게 @SpringBootApplication 와 그 안의 @Configuration, @EnableAutoConfiguration, @ComponentScan 에 대해 간단히 살펴보았다.

그러면 생성된 Bean을 **누가** 등록해줄까?  스프링 빈 컨테이너다. 

> 스프링 빈 컨테이너는 인스턴스의 생명주기를 관리한다.  
> 컨테이너의 종류는 ApplicationContext와 BeanFactory 2가지로 나누어지는데,   
> 둘의 차이점은 쉽게 말하면 ApplicationContext가 BeanFactory의 향상된 버전이라 한다.

`ApplicationContext` 는 run() 메서드를 통해 Java configure를 읽어 bean을 등록한다. 
싱글턴으로  객체 관리를 하기 때문에 한번만 실행된다. 







<br><br>

<br><br>

# :key: ​Spring Boot 구조의 이해 - 우리의 문제점은 여기에

ApplicationContext , 빈 관리 등 스프링 구조를 잘 몰랐기 때문에 발생한 문제였다. 기준이 되는 패키지를 생각하고 형상관리를 했어야 했다.... 문제를 알았으니 이제 해결해야겠죠

![배포성공path](https://mand2.github.io/assets/images/spring-4/boot_1021_path2.JPG)

![배포성공pom](https://mand2.github.io/assets/images/spring-4/boot_1021_pom2.JPG)

<br><br>

프로젝트를 하면서 컴퓨터 구조를 확실하게 알아야겠다는 생각을 많이 했다. 나 뿐만 아니라 우리 팀원 모두 그런 느낌을 받은건 우연이 아닌것 같다. 빠른 문제 해결을 위해선 기본적인 구조를 파악하고 체화해야 함을,, 오늘도 배운다- 까먹을 땐 이 블로그 포스트를 보며 다시 공부하자 :grinning:



<br><br>


출처: 

* [기본기를 쌓는 정아마추어 코딩블로그](https://jeong-pro.tistory.com/151)
* [개발/일상_Mr.lee](https://lee-mandu.tistory.com/343)
* [jhkang-dev님의 블로그](https://jhkang-tech.tistory.com/44)
* [https://sieunlim.tistory.com/10](https://sieunlim.tistory.com/10)



<br><br>

<br><br>